---
import type { Project } from 'types';
import { urlFor } from '../utils/sanity-client';

interface Props {
    projects: Project[];
}

const { projects } = Astro.props;

// Replicate grid logic parameters for SSR
const rows = 10;
// Duplicate projects to fill grid if needed (simulating the client-side logic for consistency)
// The client script logic:
// const remainder = rawProjects.length % rows; ...
// const projects = [...rawProjects, ...];
// The client script duplicates rawProjects 8 times in the example!
// We should probably just pass the raw data and let the client script build the DOM?
// But previously I decided to SSR.
// If I SSR, I need to generate exactly the same number of items.
// Let's replicate the logic:

let displayProjects = [...projects];
const remainder = displayProjects.length % rows;
if (remainder !== 0) {
    const missing = rows - remainder;
    for (let i = 0; i < missing; i++) displayProjects.push(displayProjects[i]);
}
// Duplicate 8 times as per original script
let gridItems: Project[] = [];
for (let i = 0; i < 8; i++) {
    gridItems = [...gridItems, ...displayProjects];
}

const cols = gridItems.length / rows;
const itemWidth = 240;
const itemHeight = 300;
const gap = 10;
const verticalOffset = 40;
---

<div id="viewport" class="fixed inset-0 w-full h-full z-10 overflow-hidden" style="touch-action: none;">
    <div id="grid-layer" class="absolute top-0 left-0 w-full h-full">
        {
            gridItems.map((project, i) => {
                const colIndex = i % cols;
                const rowIndex = Math.floor(i / cols);
                const offsetY = colIndex % 2 !== 0 ? verticalOffset : 0;
                const bx = colIndex * (itemWidth + gap);
                const by = rowIndex * (itemHeight + gap) + offsetY;

                const num = ((i % projects.length) + 1).toString().padStart(2, '0');
                const imageUrl = project.mainImage ? urlFor(project.mainImage).width(400).format('webp').url() : '';

                return (
                    <div
                        class="grid-item absolute will-change-transform flex items-center justify-center pointer-events-auto"
                        style={`width: ${itemWidth}px; height: ${itemHeight}px;`}
                        data-bx={bx}
                        data-by={by}
                        onclick={`handleGridClick(event, '${project.slug.current}')`}
                    >
                        <div class="grid-img-container w-full h-full relative rounded-sm shadow-sm group cursor-pointer overflow-hidden">
                            {imageUrl && <img src={imageUrl} class="w-full h-full object-cover" loading="lazy" alt={project.title} />}
                            <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4">
                                <span class="text-white/50 text-[10px] font-bold font-sans mb-1 translate-y-2 group-hover:translate-y-0 transition-transform duration-300">
                                    {num}
                                </span>
                                <h3 class="text-white font-bold text-sm leading-tight translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-75">
                                    {project.title}
                                </h3>
                                <p class="text-white/70 text-[10px] font-medium translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-100">
                                    {project.description}
                                </p>
                            </div>
                        </div>
                    </div>
                );
            })
        }
    </div>
</div>

<script define:vars={{ cols, rows, itemWidth, itemHeight, gap, verticalOffset, totalWidth: cols * (itemWidth + gap), totalHeight: rows * (itemHeight + gap) }}>
    const gridLayer = document.getElementById('grid-layer');
    const items = Array.from(document.querySelectorAll('.grid-item')).map((el) => ({
        el,
        baseX: parseFloat(el.getAttribute('data-bx')),
        baseY: parseFloat(el.getAttribute('data-by'))
    }));

    // --- SCALE / ZOOM VARIABLES ---
    let currentScale = 1;
    let startScale = 1;
    let initialDistance = 0;

    // --- MOBILE INTERACTION STATE ---
    let activeItem = null;
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    // Global click to clear selection
    if (isTouch) {
        window.addEventListener('click', (e) => {
            const clickedItem = e.target.closest('.grid-item');
            if (!clickedItem && activeItem) {
                // Clicked background, clear active
                activeItem.classList.remove('mobile-active');
                activeItem.querySelector('.grid-img-container .absolute').classList.remove('opacity-100'); // Force clear helper
                activeItem = null;
            }
        });
    }

    window.handleGridClick = function (e, slug) {
        // Draggable handles drag-prevention automatically (click event won't fire if dragged)

        if (!isTouch) {
            // Desktop: Navigate immediately
            window.location.href = `/project/${slug}`;
            return;
        }

        // Mobile Logic
        const item = e.currentTarget;

        if (activeItem === item) {
            // Second tap: Navigate
            window.location.href = `/project/${slug}`;
        } else {
            // First tap: Activate
            if (activeItem) {
                activeItem.classList.remove('mobile-active');
            }
            activeItem = item;
            activeItem.classList.add('mobile-active');
        }
    };

    // --- RENDER LOOP ---
    let xPos = 0,
        yPos = 0;
    let lastX = 0;
    let velX = 0;

    function render() {
        velX = xPos - lastX;
        lastX = xPos;

        // Apply global scale to the entire grid layer
        gsap.set(gridLayer, { scale: currentScale });

        // Infinite Wrap Logic (Center Origin)
        items.forEach((item) => {
            let dx = (item.baseX + xPos) % totalWidth;
            let dy = (item.baseY + yPos) % totalHeight;

            // Adjust buffer for zoom
            const buffer = 400;

            if (dx < -(itemWidth + buffer)) dx += totalWidth;
            if (dx > totalWidth - (itemWidth + buffer)) dx -= totalWidth;

            if (dx < -(itemHeight + buffer)) dy += totalHeight;
            if (dy > totalHeight - (itemHeight + buffer)) dy -= totalHeight;

            dx -= totalWidth / 2;
            dy -= totalHeight / 2;

            if (dx < -totalWidth / 2) dx += totalWidth;
            if (dx > totalWidth / 2) dx -= totalWidth;
            if (dy < -totalHeight / 2) dy += totalHeight;
            if (dy > totalHeight / 2) dy -= totalHeight;

            dx += window.innerWidth / 2;
            dy += window.innerHeight / 2 - verticalOffset / 4;

            gsap.set(item.el, { x: dx, y: dy });
        });

        requestAnimationFrame(render);
    }

    // --- PINCH ZOOM EVENTS ---
    window.addEventListener(
        'touchstart',
        (e) => {
            if (e.touches.length === 2) {
                initialDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                startScale = currentScale;
            }
        },
        { passive: true }
    );

    window.addEventListener(
        'touchmove',
        (e) => {
            if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const delta = dist / initialDistance;
                let newScale = startScale * delta;

                // Limits: Max 1 (default size), Min 0.6 (zoomed out)
                if (newScale > 1) newScale = 1;
                if (newScale < 0.6) newScale = 0.6;

                currentScale = newScale;
            }
        },
        { passive: true }
    );

    // --- DRAGGABLE ---
    if (typeof Draggable !== 'undefined') {
        if (typeof InertiaPlugin !== 'undefined') {
            gsap.registerPlugin(Draggable, InertiaPlugin);
        }

        const dragInstance = Draggable.create(document.createElement('div'), {
            trigger: document.getElementById('viewport'),
            type: 'x,y',
            inertia: {
                resistance: 200, // Smooth glide, not too slippery, not too heavy
                end: {
                    x: { min: -1000000, max: 1000000 },
                    y: { min: -1000000, max: 1000000 }
                }
            },
            dragResistance: 0, // 1:1 Response
            edgeResistance: 0.5,
            overshootTolerance: 0,
            allowEventDefault: false,
            onDrag: function () {
                xPos = this.x;
                yPos = this.y;
            },
            onThrowUpdate: function () {
                xPos = this.x;
                yPos = this.y;
            }
        })[0];

        window.addEventListener(
            'wheel',
            (e) => {
                const speed = 0.8;
                xPos -= e.deltaX * speed;
                yPos -= e.deltaY * speed;
                gsap.set(dragInstance.target, { x: xPos, y: yPos });
                dragInstance.update();
            },
            { passive: true }
        );
    }

    render();

    // Intro Animation
    const tl = gsap.timeline();
    tl.from(
        '.grid-item',
        {
            scale: 0.8,
            opacity: 0,
            duration: 1.0,
            stagger: {
                amount: 0.5,
                from: 'center',
                grid: [rows, cols]
            },
            ease: 'expo.out'
        },
        '+=0.2'
    );
</script>
