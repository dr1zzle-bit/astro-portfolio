---
import type { Project } from 'types';
import { urlFor } from '../utils/sanity-client';

interface Props {
    projects: Project[];
    scale?: number;
    mobileScale?: number;
    resolution?: number;
}

const { projects, scale = 1, mobileScale = 1, resolution = 1 } = Astro.props;

// Replicate grid logic parameters for SSR
const rows = 10;
// Duplicate projects to fill grid if needed (simulating the client-side logic for consistency)
// The client script logic:
// const remainder = rawProjects.length % rows; ...
// const projects = [...rawProjects, ...];
// The client script duplicates rawProjects 8 times in the example!
// We should probably just pass the raw data and let the client script build the DOM?
// But previously I decided to SSR.
// If I SSR, I need to generate exactly the same number of items.
// Let's replicate the logic:

let displayProjects = [...projects];
const remainder = displayProjects.length % rows;
if (remainder !== 0) {
    const missing = rows - remainder;
    for (let i = 0; i < missing; i++) displayProjects.push(displayProjects[i]);
}
// Duplicate 8 times as per original script
let gridItems: Project[] = [];
for (let i = 0; i < 8; i++) {
    gridItems = [...gridItems, ...displayProjects];
}

const cols = gridItems.length / rows;
const baseItemWidth = 240;
const baseItemHeight = 300;

// SSR initial style (Desktop default)
const itemWidth = baseItemWidth * scale;
const itemHeight = baseItemHeight * scale;

const gap = 10;
const verticalOffset = 40;
---

<div id="viewport" class="fixed inset-0 w-full h-full z-10 overflow-hidden" style="touch-action: none;">
    <div id="grid-layer" class="absolute top-0 left-0 w-full h-full">
        {
            gridItems.map((project, i) => {
                const colIndex = i % cols;
                const rowIndex = Math.floor(i / cols);
                const offsetY = colIndex % 2 !== 0 ? verticalOffset : 0;
                const bx = colIndex * (itemWidth + gap);
                const by = rowIndex * (itemHeight + gap) + offsetY;

                const num = ((i % projects.length) + 1).toString().padStart(2, '0');

                // Scale thumbnail resolution
                const thumbWidth = Math.round(400 * resolution);
                const thumbHeight = Math.round(500 * resolution);

                const imageUrl = project.mainImage ? urlFor(project.mainImage).width(thumbWidth).height(thumbHeight).fit('crop').format('webp').url() : '';

                return (
                    <div
                        class="grid-item absolute will-change-transform flex items-center justify-center pointer-events-auto"
                        style={`width: ${itemWidth}px; height: ${itemHeight}px; left: 0; top: 0;`}
                        data-col={colIndex}
                        data-row={rowIndex}
                        onclick={`handleGridClick(event, '${project.slug.current}')`}
                    >
                        <div class="grid-img-container w-full h-full relative rounded-sm shadow-sm group cursor-pointer overflow-hidden">
                            {imageUrl && <img src={imageUrl} class="w-full h-full object-cover" loading="lazy" alt={project.title} />}
                            <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4">
                                <span class="text-white/50 text-[10px] font-bold font-sans mb-1 translate-y-2 group-hover:translate-y-0 transition-transform duration-300">
                                    {num}
                                </span>
                                <h3 class="text-white font-bold text-sm leading-tight translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-75">
                                    {project.title}
                                </h3>
                                <p class="text-white/70 text-[10px] font-medium translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-100">
                                    {project.description}
                                </p>
                            </div>
                        </div>
                    </div>
                );
            })
        }
    </div>
</div>

<script define:vars={{ cols, rows, scale, mobileScale, gap, verticalOffset }}>
    const gridLayer = document.getElementById('grid-layer');
    const baseItemWidth = 240;
    const baseItemHeight = 300;

    // --- RESPONSIVE STATE ---
    let currentItemWidth = baseItemWidth * scale;
    let currentItemHeight = baseItemHeight * scale;
    let totalWidth = cols * (currentItemWidth + gap);
    let totalHeight = rows * (currentItemHeight + gap);

    // Initialize Items with Row/Col data
    const items = Array.from(document.querySelectorAll('.grid-item')).map((el) => ({
        el,
        colIndex: parseInt(el.getAttribute('data-col')),
        rowIndex: parseInt(el.getAttribute('data-row')),
        baseX: 0,
        baseY: 0
    }));

    function updateGridDimensions() {
        const isMobile = window.innerWidth < 768;
        const currentScale = isMobile ? mobileScale : scale;

        currentItemWidth = baseItemWidth * currentScale;
        currentItemHeight = baseItemHeight * currentScale;

        totalWidth = cols * (currentItemWidth + gap);
        totalHeight = rows * (currentItemHeight + gap);

        // Recalculate positions
        items.forEach((item) => {
            const offsetY = item.colIndex % 2 !== 0 ? verticalOffset : 0;
            item.baseX = item.colIndex * (currentItemWidth + gap);
            item.baseY = item.rowIndex * (currentItemHeight + gap) + offsetY;

            // Update DOM dimensions
            item.el.style.width = `${currentItemWidth}px`;
            item.el.style.height = `${currentItemHeight}px`;
        });
    }

    // Initial calculation
    updateGridDimensions();

    // Update on resize
    window.addEventListener('resize', updateGridDimensions);

    // --- SCALE / ZOOM VARIABLES ---
    let currentScale = 1;
    let startScale = 1;
    let initialDistance = 0;

    // --- MOBILE INTERACTION STATE ---
    let activeItem = null;
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    // Global click to clear selection
    if (isTouch) {
        window.addEventListener('click', (e) => {
            const clickedItem = e.target.closest('.grid-item');
            if (!clickedItem && activeItem) {
                // Clicked background, clear active
                activeItem.classList.remove('mobile-active');
                activeItem.querySelector('.grid-img-container .absolute').classList.remove('opacity-100'); // Force clear helper
                activeItem = null;
            }
        });
    }

    window.handleGridClick = function (e, slug) {
        // Draggable handles drag-prevention automatically (click event won't fire if dragged)

        if (!isTouch) {
            // Desktop: Navigate immediately
            window.location.href = `/project/${slug}`;
            return;
        }

        // Mobile Logic
        const item = e.currentTarget;

        if (activeItem === item) {
            // Second tap: Navigate
            window.location.href = `/project/${slug}`;
        } else {
            // First tap: Activate
            if (activeItem) {
                activeItem.classList.remove('mobile-active');
            }
            activeItem = item;
            activeItem.classList.add('mobile-active');
        }
    };

    // --- RENDER LOOP ---
    let xPos = 0,
        yPos = 0;
    let lastX = 0;
    let velX = 0;

    // --- DRAGGABLE & CUSTOM PHYSICS ---
    let isDragging = false;
    let velocityX = 0;
    let velocityY = 0;
    const friction = 0.95; // Slightly more resistance for "gentler" stop
    const velocityMultiplier = 0.75; // Dampen the input speed so it doesn't fly too fast

    if (typeof Draggable !== 'undefined') {
        const dummyDiv = document.createElement('div');

        const dragInstance = Draggable.create(dummyDiv, {
            trigger: document.getElementById('viewport'),
            type: 'x,y',
            dragResistance: 0,
            allowEventDefault: false,
            onDragStart: function () {
                // Abort if multi-touch (Zooming)
                if (this.pointerEvent.touches && this.pointerEvent.touches.length > 1) {
                    isDragging = false;
                    return;
                }
                isDragging = true;
                velocityX = 0;
                velocityY = 0;
            },
            onDrag: function () {
                // Ignore if zooming
                if (this.pointerEvent.touches && this.pointerEvent.touches.length > 1) {
                    isDragging = false;
                    return;
                }
                xPos = this.x;
                yPos = this.y;
            },
            onDragEnd: function () {
                isDragging = false;
            }
        })[0];

        // --- RENDER LOOP WITH PHYSICS ---
        function physicsRender() {
            if (isDragging) {
                // Track Velocity with Dampening
                velocityX = (xPos - lastX) * velocityMultiplier;
                velocityY = (yPos - lastY) * velocityMultiplier;
            } else {
                // Apply Momentum
                if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
                    xPos += velocityX;
                    yPos += velocityY;
                    velocityX *= friction;
                    velocityY *= friction;

                    // Sync Draggable Proxy
                    gsap.set(dummyDiv, { x: xPos, y: yPos });
                    dragInstance.update();
                }
            }

            lastX = xPos;
            lastY = yPos;

            // Helper for infinite wrap vars
            const totalW = totalWidth;
            const totalH = totalHeight;

            // Apply global scale
            gsap.set(gridLayer, { scale: currentScale });

            // Infinite Wrap Logic (Optimized)
            items.forEach((item) => {
                let dx = (item.baseX + xPos) % totalW;
                let dy = (item.baseY + yPos) % totalH;
                const buffer = 400;

                // Use current dimensions for buffer calculation
                const w = currentItemWidth;
                const h = currentItemHeight;

                if (dx < -(w + buffer)) dx += totalW;
                if (dx > totalW - (w + buffer)) dx -= totalW;

                if (dy < -(h + buffer)) dy += totalH;
                if (dy > totalH - (h + buffer)) dy -= totalH;

                dx -= totalW / 2;
                dy -= totalH / 2;

                if (dx < -totalW / 2) dx += totalW;
                if (dx > totalW / 2) dx -= totalW;
                if (dy < -totalH / 2) dy += totalH;
                if (dy > totalH / 2) dy -= totalH;

                dx += window.innerWidth / 2;
                dy += window.innerHeight / 2 - verticalOffset / 4;

                gsap.set(item.el, { x: dx, y: dy });
            });

            requestAnimationFrame(physicsRender);
        }

        // Start the physics loop
        physicsRender();

        // Wheel support
        window.addEventListener(
            'wheel',
            (e) => {
                const speed = 1.2;
                xPos -= e.deltaX * speed;
                yPos -= e.deltaY * speed;
                velocityX = 0;
                velocityY = 0;
                gsap.set(dummyDiv, { x: xPos, y: yPos });
                dragInstance.update();
            },
            { passive: true }
        );
    } else {
        // Fallback if Draggable missing
        // render(); // Deleted old render, physicsRender covers it
    }

    // --- PINCH ZOOM EVENTS ---
    window.addEventListener(
        'touchstart',
        (e) => {
            if (e.touches.length === 2) {
                initialDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                startScale = currentScale;
            }
        },
        { passive: true }
    );

    window.addEventListener(
        'touchmove',
        (e) => {
            if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const delta = dist / initialDistance;
                let newScale = startScale * delta;

                // Limits: Max 1 (default size), Min 0.6 (zoomed out)
                if (newScale > 1) newScale = 1;
                if (newScale < 0.6) newScale = 0.6;

                currentScale = newScale;
            }
        },
        { passive: true }
    );

    // Intro Animation
    const tl = gsap.timeline();
    tl.from(
        '.grid-item',
        {
            scale: 0.8,
            opacity: 0,
            duration: 1.0,
            stagger: {
                amount: 0.5,
                from: 'center',
                grid: [rows, cols]
            },
            ease: 'expo.out'
        },
        '+=0.2'
    );
</script>
