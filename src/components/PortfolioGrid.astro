---
import type { Project } from 'types';
import { urlFor } from '../utils/sanity-client';

interface Props {
    projects: Project[];
}

const { projects } = Astro.props;

// Replicate grid logic parameters for SSR
const rows = 10;
// Duplicate projects to fill grid if needed (simulating the client-side logic for consistency)
// The client script logic:
// const remainder = rawProjects.length % rows; ...
// const projects = [...rawProjects, ...];
// The client script duplicates rawProjects 8 times in the example!
// We should probably just pass the raw data and let the client script build the DOM?
// But previously I decided to SSR.
// If I SSR, I need to generate exactly the same number of items.
// Let's replicate the logic:

let displayProjects = [...projects];
const remainder = displayProjects.length % rows;
if (remainder !== 0) {
    const missing = rows - remainder;
    for (let i = 0; i < missing; i++) displayProjects.push(displayProjects[i]);
}
// Duplicate 8 times as per original script
let gridItems: Project[] = [];
for (let i = 0; i < 8; i++) {
    gridItems = [...gridItems, ...displayProjects];
}

const cols = gridItems.length / rows;
const itemWidth = 240;
const itemHeight = 300;
const gap = 10;
const verticalOffset = 40;
---

<div id="viewport" class="fixed inset-0 w-full h-full z-10 overflow-hidden" style="touch-action: none;">
    <div id="grid-layer" class="absolute top-0 left-0 w-full h-full">
        {
            gridItems.map((project, i) => {
                const colIndex = i % cols;
                const rowIndex = Math.floor(i / cols);
                const offsetY = colIndex % 2 !== 0 ? verticalOffset : 0;
                const bx = colIndex * (itemWidth + gap);
                const by = rowIndex * (itemHeight + gap) + offsetY;

                const num = ((i % projects.length) + 1).toString().padStart(2, '0');
                const imageUrl = project.mainImage ? urlFor(project.mainImage).width(400).format('webp').url() : '';

                return (
                    <div
                        class="grid-item absolute will-change-transform flex items-center justify-center pointer-events-auto"
                        style={`width: ${itemWidth}px; height: ${itemHeight}px;`}
                        data-bx={bx}
                        data-by={by}
                        onclick={`handleGridClick(event, '${project.slug.current}')`}
                    >
                        <div class="grid-img-container w-full h-full relative rounded-sm shadow-sm group cursor-pointer overflow-hidden">
                            {imageUrl && <img src={imageUrl} class="w-full h-full object-cover" loading="lazy" alt={project.title} />}
                            <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4">
                                <span class="text-white/50 text-[10px] font-bold font-sans mb-1 translate-y-2 group-hover:translate-y-0 transition-transform duration-300">
                                    {num}
                                </span>
                                <h3 class="text-white font-bold text-sm leading-tight translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-75">
                                    {project.title}
                                </h3>
                                <p class="text-white/70 text-[10px] font-medium translate-y-2 group-hover:translate-y-0 transition-transform duration-300 delay-100">
                                    {project.description}
                                </p>
                            </div>
                        </div>
                    </div>
                );
            })
        }
    </div>
</div>

<script define:vars={{ cols, rows, itemWidth, itemHeight, gap, verticalOffset, totalWidth: cols * (itemWidth + gap), totalHeight: rows * (itemHeight + gap) }}>
    const gridLayer = document.getElementById('grid-layer');
    const items = Array.from(document.querySelectorAll('.grid-item')).map((el) => ({
        el,
        baseX: parseFloat(el.getAttribute('data-bx')),
        baseY: parseFloat(el.getAttribute('data-by'))
    }));

    // --- SCALE / ZOOM VARIABLES ---
    let currentScale = 1;
    let startScale = 1;
    let initialDistance = 0;

    // --- MOBILE INTERACTION STATE ---
    let activeItem = null;
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    // Global click to clear selection
    if (isTouch) {
        window.addEventListener('click', (e) => {
            const clickedItem = e.target.closest('.grid-item');
            if (!clickedItem && activeItem) {
                // Clicked background, clear active
                activeItem.classList.remove('mobile-active');
                activeItem.querySelector('.grid-img-container .absolute').classList.remove('opacity-100'); // Force clear helper
                activeItem = null;
            }
        });
    }

    window.handleGridClick = function (e, slug) {
        // Draggable handles drag-prevention automatically (click event won't fire if dragged)

        if (!isTouch) {
            // Desktop: Navigate immediately
            window.location.href = `/project/${slug}`;
            return;
        }

        // Mobile Logic
        const item = e.currentTarget;

        if (activeItem === item) {
            // Second tap: Navigate
            window.location.href = `/project/${slug}`;
        } else {
            // First tap: Activate
            if (activeItem) {
                activeItem.classList.remove('mobile-active');
            }
            activeItem = item;
            activeItem.classList.add('mobile-active');
        }
    };

    // --- RENDER LOOP ---
    let xPos = 0,
        yPos = 0;
    let lastX = 0;
    let velX = 0;

    // --- DRAGGABLE & CUSTOM PHYSICS ---
    let isDragging = false;
    let velocityX = 0;
    let velocityY = 0;
    const friction = 0.96; // Adjusts glide duration (closer to 1 = longer)

    if (typeof Draggable !== 'undefined') {
        const dummyDiv = document.createElement('div');

        const dragInstance = Draggable.create(dummyDiv, {
            trigger: document.getElementById('viewport'),
            type: 'x,y',
            dragResistance: 0,
            allowEventDefault: false,
            onDragStart: () => {
                isDragging = true;
                velocityX = 0;
                velocityY = 0;
            },
            onDrag: function () {
                xPos = this.x;
                yPos = this.y;
            },
            onDragEnd: function () {
                isDragging = false;
                // Boost velocity slightly for better "fling" feel
                // The velocityX/Y are calculated in the render loop based on movement
            }
        })[0];

        // --- RENDER LOOP WITH PHYSICS ---
        // Overwriting the previous render function to include momentum
        function physicsRender() {
            if (isDragging) {
                // Track Velocity
                // Current xPos is set by Draggable
                velocityX = xPos - lastX;
                velocityY = yPos - lastY;
            } else {
                // Apply Momentum
                if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
                    xPos += velocityX;
                    yPos += velocityY;
                    velocityX *= friction;
                    velocityY *= friction;

                    // Sync Draggable Proxy so next drag starts from correct spot
                    gsap.set(dummyDiv, { x: xPos, y: yPos });
                    dragInstance.update();
                }
            }

            lastX = xPos;
            lastY = yPos; // Update last positions

            // Helper for infinite wrap vars
            const totalW = totalWidth;
            const totalH = totalHeight;

            // Apply global scale
            gsap.set(gridLayer, { scale: currentScale });

            // Infinite Wrap Logic (Optimized)
            items.forEach((item) => {
                let dx = (item.baseX + xPos) % totalW;
                let dy = (item.baseY + yPos) % totalH;
                const buffer = 400;

                if (dx < -(itemWidth + buffer)) dx += totalW;
                if (dx > totalW - (itemWidth + buffer)) dx -= totalW;

                if (dx < -(itemHeight + buffer)) dy += totalH;
                if (dy > totalH - (itemHeight + buffer)) dy -= totalH;

                dx -= totalW / 2;
                dy -= totalH / 2;

                // Wrap Logic 2 (Centering)
                if (dx < -totalW / 2) dx += totalW;
                if (dx > totalW / 2) dx -= totalW;
                if (dy < -totalH / 2) dy += totalH;
                if (dy > totalH / 2) dy -= totalH;

                dx += window.innerWidth / 2;
                dy += window.innerHeight / 2 - verticalOffset / 4;

                gsap.set(item.el, { x: dx, y: dy });
            });

            requestAnimationFrame(physicsRender);
        }

        // Start the physics loop instead of the basic render
        physicsRender();

        // Wheel support for custom physics
        window.addEventListener(
            'wheel',
            (e) => {
                const speed = 1.2;
                xPos -= e.deltaX * speed;
                yPos -= e.deltaY * speed;

                // Kill momentum on wheel scrape
                velocityX = 0;
                velocityY = 0;

                gsap.set(dummyDiv, { x: xPos, y: yPos });
                dragInstance.update();
            },
            { passive: true }
        );
    } else {
        // Fallback if Draggable missing
        render();
    }

    // Intro Animation
    const tl = gsap.timeline();
    tl.from(
        '.grid-item',
        {
            scale: 0.8,
            opacity: 0,
            duration: 1.0,
            stagger: {
                amount: 0.5,
                from: 'center',
                grid: [rows, cols]
            },
            ease: 'expo.out'
        },
        '+=0.2'
    );
</script>
